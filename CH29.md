# **Capítulo 29 – Introduction to Automation Tools**

Este capítulo presenta las **herramientas más utilizadas en automatización de redes**, desde scripts básicos hasta plataformas de orquestación y controladores SDN. Su objetivo es que el ingeniero de redes entienda qué herramienta usar en cada etapa del ciclo de automatización.

---

# **1. Por qué necesitamos herramientas de automatización**

La automatización resuelve problemas clásicos en redes:

- Configuraciones manuales propensas a error
    
- Miles de dispositivos con configuraciones repetitivas
    
- Actualizaciones que requieren consistencia
    
- Falta de validación y pruebas del estado de la red
    
- Necesidad de telemetría en tiempo real
    

Las herramientas modernas permiten:

- Despliegues rápidos
    
- Políticas consistentes
    
- Validación automática
    
- Integraciones con CI/CD
    
- Reducción de errores humanos
    

---

# **2. Clasificación de herramientas de automatización**

Las herramientas usadas en networking se dividen en tres grandes categorías:

## **2.1 Herramientas de configuración y ejecución (Device-centric)**

Ejecutan configuraciones directamente sobre equipos.

Incluyen:

- **Python scripting** (Paramiko, Netmiko, NAPALM)
    
- **Ansible**
    
- **SaltStack**
    
- **Chef / Puppet (legacy en networking)**
    

Estas herramientas se conectan por:

- SSH
    
- NETCONF
    
- RESTCONF
    
- APIs propietarias
    

---

## **2.2 Herramientas de orquestación (Orchestrators)**

Encargadas de coordinar cambios en múltiples dispositivos:

- **Cisco DNA Center** (Campus SDN)
    
- **Cisco vManage** (SD-WAN)
    
- **Cisco APIC/ACI** (Data Center SDN)
    
- **Cisco NSO (Network Services Orchestrator)**
    
- **Terraform (cuando se usa para networking)**
    

Los orquestadores son “controladores” centrados en políticas e intent-based networking.

---

## **2.3 Herramientas de desarrollo y pipelines (DevOps)**

Integran automatización con CI/CD:

- Git
    
- GitHub / GitLab
    
- Jenkins
    
- Docker
    
- Kubernetes (cuando se integran microservicios o agentes de red)
    

---

# **3. Python: lenguaje base de la automatización de redes**

Python es el estándar de facto porque:

- Es sencillo
    
- Tiene librerías específicas para networking
    
- Se integra con APIs, NETCONF, RESTCONF
    
- Soporta validación, testing y CI/CD
    

Bibliotecas típicas:

- **Paramiko** – SSH crudo
    
- **Netmiko** – Simplifica SSH para Cisco, Juniper, etc.
    
- **NAPALM** – Abstracción multivendor
    
- **Requests** – Consumir APIs REST
    
- **ncclient** – NETCONF
    

Ejemplo básico:

```
from netmiko import ConnectHandler

device = {
  "device_type": "cisco_ios",
  "host": "10.10.10.1",
  "username": "admin",
  "password": "cisco123"
}

conn = ConnectHandler(**device)
output = conn.send_command("show ip interface brief")
print(output)
```

---

# **4. Ansible: automatización sin agentes**

Ansible es clave en ENCOR porque:

- No usa agentes
    
- Se basa en SSH/NETCONF
    
- Playbooks YAML → idempotencia
    
- Escala bien
    
- Es multivendor
    

Playbook simple:

```
- hosts: switches
  gather_facts: no
  tasks:
    - name: Configurar hostname
      ios_config:
        lines:
          - hostname SW1
```

Módulos relevantes:

- ios_config
    
- ios_facts
    
- nxos_config
    
- iosxr_config
    
- asa_config
    

---

# **5. Cisco NSO (Network Services Orchestrator)**

NSO es uno de los orquestadores más poderosos a nivel carrier-grade.

Características:

- Basado en **YANG**
    
- Automatización transaccional (rollback automático)
    
- Multivendor
    
- Extensible por Python
    

Implementa el concepto **service model**, donde describes _lo que quieres_, y NSO traduce a configuraciones por equipo.

---

# **6. Controladores Cisco en automatización**

## **6.1 Cisco DNA Center**

- Operación basada en intent
    
- APIs REST
    
- Provisioning automatizado
    
- Assurance / Telemetría
    
- Plantillas (templates)
    

APIs comunes:

- Endpoint: `/dna/intent/api/v1/network-device`
    
- Permite: discovery, configuración, QoS, templates, políticas SGT.
    

---

## **6.2 Cisco SD-WAN (vManage)**

- Control centralizado del fabric
    
- Zero Touch Provisioning
    
- APIs REST muy usadas
    
- Plantillas de política, data-plane y control-plane
    

---

## **6.3 Cisco ACI (APIC)**

- SDN para Data Centers
    
- Policy-based networking
    
- API-first design (todo se hace por API)
    
- JSON/XML/REST
    

Permite automatizar:

- Tenants
    
- VRFs
    
- Bridge domains
    
- Contracts
    
- EPGs
    

---

# **7. Herramientas DevOps aplicadas a redes**

## **7.1 Git / GitHub / GitLab**

- Control de versiones de configuraciones
    
- Validación de cambios
    
- Pull Requests → revisión antes de desplegar
    
- Historial completo
    

---

## **7.2 Jenkins / GitLab CI**

Permiten pipelines como:

- Validación de plantillas YANG
    
- Pruebas de configuración contra sandbox
    
- Despliegue automatizado a producción
    
- Testing post-deployment
    

Ejemplo "pipeline" básico:

```
1. Developer hace commit → Git
2. Jenkins ejecuta test (linting, simular config)
3. Jenkins despliega config a staging
4. Validación
5. Deploy a producción
```

---

# **8. Modelos de despliegue (Push vs Pull)**

|Modelo|Explicación|Ejemplos|
|---|---|---|
|**Push-based**|La herramienta empuja la conf.|Ansible, Python, NSO, DNA|
|**Pull-based**|El dispositivo o agente “pide” la conf.|Puppet (legacy), algunos casos SD-WAN|

---

# **9. Infraestructura como Código (IaC)**

Concepto muy importante:

- La red se define como archivos
    
- Validables, versionables, testeables
    
- Repetibles
    
- Comparables
    

Herramientas:

- Terraform
    
- Ansible
    
- NSO
    
- Python + Git
    

---

# **10. Validación automatizada (Pre y Post-Checks)**

Buenas prácticas antes/después de:

- Verificar BGP, OSPF, STP
    
- Revisar interfaces
    
- Medir latencia/telemetría
    
- Comparar estado deseado vs real
    
- Registrar los cambios
    

Automatización moderna requiere **test-driven networking**.