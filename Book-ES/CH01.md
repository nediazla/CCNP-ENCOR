## CAPÍTULO 1

### Reenvío de paquetes

Este capítulo cubre los siguientes temas:

- **Comunicación entre dispositivos de red**: esta sección explica cómo los switches reenvían tráfico desde una **perspectiva de Capa 2** y cómo los routers reenvían tráfico desde una **perspectiva de Capa 3**.
    
- **Arquitecturas de reenvío**: esta sección analiza los **mecanismos utilizados en routers y switches** para reenviar el tráfico de red.
    

Este capítulo proporciona una **revisión de los fundamentos básicos de redes** y profundiza en los **conceptos técnicos** relacionados con cómo el tráfico de red es reenviado a través de la arquitectura de un **router o un switch**.

---

**Comunicación entre dispositivos de red**

La función principal de una red es proporcionar conectividad entre dispositivos. Antes existía una variedad de protocolos de red que eran específicos o preferidos; hoy en día, prácticamente todo se basa en el **Protocolo de Control de Transmisión/Protocolo de Internet (TCP/IP)**.

Es importante señalar que TCP/IP se basa en el concepto del modelo **Interconexión de Sistemas Abiertos (OSI)**, el cual está compuesto por siete capas. Cada capa describe una función específica, y una capa puede modificarse o cambiarse sin requerir cambios en la capa superior o inferior.

El modelo OSI, que proporciona un enfoque estructurado para la compatibilidad entre fabricantes, se ilustra en la Figura 1-1.
![[img/Pasted image 20251230104933.png]]

Cuando se piensa en el flujo de datos, la mayor parte del tráfico de red implica la comunicación de datos entre aplicaciones. Las aplicaciones generan datos en la **Capa 7**, y el dispositivo o host envía esos datos hacia abajo a través del modelo OSI. A medida que los datos descienden por el modelo OSI, se encapsulan o modifican según sea necesario.

En la **Capa 3**, el dispositivo o host decide si los datos deben enviarse a otra aplicación en el mismo dispositivo y, en ese caso, comienza a mover los datos hacia arriba en la pila. O bien, si los datos deben enviarse a un dispositivo diferente, el dispositivo o host continúa procesándolos hacia abajo en el modelo OSI hasta la **Capa 1**. La **Capa 1** es responsable de transmitir la información a través del medio, por ejemplo, cable, fibra o ondas de radio. En el lado receptor, los datos comienzan en la **Capa 1**, luego pasan a la **Capa 2**, y así sucesivamente, hasta que han subido completamente hasta la **Capa 7** y llegan a la aplicación receptora.

Este capítulo refuerza conceptos relacionados con cómo un dispositivo de red reenvía tráfico desde una perspectiva de **Capa 2** o de **Capa 3**. Inicialmente, los dispositivos de red eran puentes o switches, y los dispositivos de Capa 3 eran estrictamente routers. A medida que la tecnología avanzó, se desarrolló el hardware físico necesario para reenviar paquetes de aplicaciones a través del **Circuito Integrado de Aplicación Específica (ASIC)**. A medida que la capacidad de conmutación a nivel de hardware se desarrolló, se inventaron los **switches multicapa (MLS)** para reenviar tráfico de Capa 2 en hardware como si fueran switches; sin embargo, también pueden realizar otras funciones, como el enrutamiento de paquetes, desde una perspectiva de **Capa 3**.
### Reenvío en la Capa 2

La segunda capa del modelo OSI, la **capa de enlace de datos**, gestiona el direccionamiento por debajo de la pila de protocolos IP, de modo que la comunicación se dirige entre hosts. Los paquetes de red incluyen direccionamiento de **Capa 2** con direcciones de origen y destino para los segmentos. Ethernet utiliza comúnmente direcciones de **Control de Acceso al Medio (MAC)**, y otros protocolos de la capa de enlace de datos, como **Frame Relay**, utilizan un método de direccionamiento de Capa 2 completamente diferente.

El enfoque del examen **Enterprise Core** está en las tecnologías Ethernet e inalámbricas, ambas de las cuales utilizan direcciones MAC para el direccionamiento de **Capa 2**. Este libro se centra en las direcciones MAC para el **reenvío en la Capa 2**.
### Dominios de colisión

Ethernet es un medio de comunicación compartido. Cuando dos o más dispositivos de red intentan transmitir datos al mismo tiempo en el mismo segmento de red, la comunicación se vuelve ilegible debido a **colisiones de datos**. Para evitar estas colisiones, Ethernet incluye **Acceso Múltiple con Detección de Portadora y Detección de Colisiones (CSMA/CD)**, que garantiza que solo un dispositivo transmita datos a la vez dentro de un **dominio de colisión**. Un dominio de colisión es un segmento de red en el que un dispositivo puede detectar si otro dispositivo está transmitiendo datos, independientemente del dispositivo de destino. Si un dispositivo detecta que otro está transmitiendo datos, retrasa su transmisión hasta que el cable esté libre. Esto significa que los dispositivos solo pueden realizar una acción a la vez, ya sea transmitir o recibir datos (es decir, operan en **half-duplex**).

Cuando Ethernet se convirtió en un estándar del **Instituto de Ingenieros Eléctricos y Electrónicos (IEEE)** bajo el estándar **802.3 CSMA/CD**, inicialmente utilizó tecnologías como **Thinnet (10BASE-2)** y **Thicknet (10BASE-5)**, que conectaban todos los dispositivos de red usando el mismo cable coaxial y conectores en T.

Con estas tecnologías, a medida que se agregaban más dispositivos al mismo dominio de colisión (el mismo cable coaxial), la red se volvía menos eficiente, ya que los dispositivos debían esperar a que el cable estuviera libre para poder transmitir datos. El cambio del medio a cableado de **Categoría 3/4** y el uso de **hubs de red** proliferaron el problema, porque compartían el mismo dominio de colisión. Los hubs de red no tienen ninguna inteligencia para dirigir el tráfico de red; simplemente repiten el tráfico que reciben por cada puerto.

Los **switches de red** mejoran la escalabilidad y la estabilidad de una red mediante la creación de canales virtuales. Un switch mantiene una tabla que asocia las direcciones Ethernet de **Control de Acceso al Medio (MAC)** de un host con el puerto por el cual ese host originó el tráfico. En lugar de reenviar todo el tráfico por cada puerto del switch, el switch utiliza la **tabla de direcciones MAC** local para reenviar el tráfico únicamente al puerto del switch asociado con la MAC de destino. Este enfoque reduce drásticamente el tamaño del dominio de colisión entre los dispositivos y permite que estos transmitan y reciban datos al mismo tiempo (es decir, operen en **full-duplex**).

La **Figura 1-2** muestra los dominios de colisión en un hub frente a un switch. Ambas topologías presentan las mismas tres PC y el mismo cableado. A la izquierda, las PC están conectadas a un hub de red. La comunicación entre **PC-A** y **PC-B** es recibida por **PC-C**.

Esto ocurre porque los tres dispositivos están en el mismo **dominio de colisión**. **PC-C** debe procesar la trama —consumiendo recursos— y luego descartar el paquete al determinar que la dirección MAC de destino no le pertenece. Además, **PC-C** debe esperar hasta que finalice la comunicación entre **PC-A** y **PC-B** antes de poder transmitir datos.

A la derecha, las PC están conectadas a un **switch de red**. La comunicación entre **PC-A** y **PC-B** se divide en dos dominios de colisión. El switch puede interconectar ambos dominios de colisión utilizando la información de su **tabla de direcciones MAC**.

![[img/Pasted image 20251230105431.png]]

Cuando un switch recibe un paquete que contiene una dirección MAC de destino que no se encuentra en la **tabla de direcciones MAC** del switch, este reenvía el paquete por **todos los puertos**, excepto por el puerto en el que se recibió el paquete. Este proceso se conoce como **flooding de unicast desconocido**, porque la dirección MAC de destino no es conocida.

El **tráfico broadcast** es tráfico de red destinado a **todos los hosts** dentro de la red de área local (LAN) y se reenvía por **cada puerto del switch**. El tráfico broadcast es indeseable porque reduce la eficiencia de la red, ya que interrumpe la comunicación unicast entre dispositivos de red. Los **broadcasts no atraviesan los límites de Capa 3** (es decir, de una subred a otra). Todos los dispositivos que residen dentro del mismo segmento de **Capa 2** se consideran parte del mismo **dominio de broadcast**.

La **Figura 1-3** ilustra cuatro PC conectadas a un switch (**SW1**) dentro del mismo segmento de **Capa 2**. También muestra la **tabla de direcciones MAC** de SW1, que asocia las PC con el puerto correspondiente del switch. En el escenario de la izquierda, **PC-A** está transmitiendo tráfico unicast a **PC-B**. **SW1** no reenvía datos fuera de los puertos **Gi0/2** o **Gi0/3**, lo cual podría interrumpir otras comunicaciones de red entre las PC. En el escenario de la derecha, **SW1** está transmitiendo tráfico broadcast proveniente de **PC-A** por **todos los puertos activos del switch**.

![[img/Pasted image 20251230105528.png]]

### LANs virtuales

Agregar un router entre segmentos LAN ayuda a reducir los dominios de broadcast y proporciona una comunicación de red óptima. La ubicación de un segmento LAN varía debido al direccionamiento de red. Una asignación deficiente de hosts puede provocar un uso ineficiente del hardware, ya que algunos puertos del switch podrían quedar sin utilizar.

Las **LANs virtuales (VLANs)** proporcionan segmentación lógica al crear **múltiples dominios de broadcast** dentro de la misma red física. Las VLANs ofrecen una mayor utilización de los puertos del switch, ya que un puerto puede asociarse al dominio de broadcast necesario y varios dominios de broadcast pueden coexistir en un mismo switch. Los dispositivos de red dentro de una VLAN **no pueden comunicarse con dispositivos de otra VLAN** sin un **router** que interconecte las VLANs.

Las VLANs están definidas en el estándar **IEEE 802.1Q**, el cual establece que se agregan **32 bits** al encabezado del paquete en los siguientes campos:

- **Identificador del protocolo de etiqueta (TPID)**: campo de 16 bits establecido en **0x8100** para identificar el paquete como un paquete 802.1Q.
    
- **Punto de prioridad (PCP)**: campo de 3 bits que indica una **clase de servicio (CoS)** como parte de la calidad de servicio (**QoS**) entre switches.
    
- **Indicador de elegibilidad de descarte (DEI)**: campo de 1 bit que indica si el paquete puede descartarse cuando existe congestión de ancho de banda.
    
- **Identificador de VLAN (VID)**: campo de 12 bits que especifica la VLAN asociada a un paquete de red.
    

La **Figura 1-4** muestra la estructura de un paquete VLAN.
![[img/Pasted image 20251230105631.png]]

El **identificador de VLAN** tiene solo **12 bits**, lo que proporciona **4094 VLANs únicas**. Los switches **Catalyst** utilizan la siguiente lógica para los identificadores de VLAN:

- **VLAN 0** está reservada para tráfico **802.1p** y no puede modificarse ni eliminarse.
    
- **VLAN 1** es la **VLAN predeterminada** y no puede modificarse ni eliminarse.
    
- **VLAN 2 a 1001** se encuentran en el **rango normal de VLAN** y pueden agregarse, eliminarse o modificarse según sea necesario.
    
- **VLAN 1002 a 1005** están reservadas y no pueden eliminarse.
    
- **VLAN 1006 a 4094** se encuentran en el **rango extendido de VLAN** y pueden agregarse, eliminarse o modificarse según sea necesario.
    

Las VLANs se crean usando el comando de configuración global **`vlan vlan-id`**. Un nombre descriptivo (hasta **32 caracteres**) se asocia a una VLAN mediante el comando de configuración del submodo VLAN **`vlan-name`**. La VLAN no se crea realmente hasta que la **interfaz de línea de comandos (CLI)** ha salido nuevamente al modo de configuración global o se ha pasado a otro identificador de VLAN.

El **Ejemplo 1-1** muestra la creación de **VLAN 10 (PCs)**, **VLAN 20 (Teléfonos)** y **VLAN 99 (Invitados)** en **SW1**.

**Ejemplo 1-1** Creación de Vlan
```
SW1# configure term 
Enter configuration commands, one per line. End with CNTL/Z. 
SW1(config)# vlan 10 
SW1(config-vlan)# name PCs 
SW1(config-vlan)# vlan 20 
SW1(config-vlan)# name Phones 
SW1(config-vlan)# vlan 99 
SW1(config-vlan)# name Guest
```

Las **VLANs** y su **asignación de puertos** se verifican mediante el comando **`show vlan [{brief | id vlan-id | name vlan-name | summary}]`**, como se demuestra en el **Ejemplo 1-2**.  
Observa que la salida se divide en **cuatro secciones principales**: **asignaciones de VLAN a puertos**, **MTU del sistema**, **sesiones SPAN** y **VLANs privadas**.

**Ejemplo 1-2** Visualización de la asignación de VLAN a puertos
```
SW1# show vlan 
! Traditional and common VLANs will be listed in this section. The ports ! associated to these VLANs are displayed to the right. 
VLAN Name                             Status    Ports
---- -------------------------------- --------- ------------------------------ 
1    default                          active     Gi1/0/1, Gi1/0/2, Gi1/0/3 
                                                 Gi1/0/4, Gi1/0/5, Gi1/0/6 
                                                 Gi1/0/10, Gi1/0/11, Gi1/0/17
                                                 Gi1/0/18, Gi1/0/19, Gi1/0/20
                                                 Gi1/0/21, Gi1/0/22, Gi1/0/23                                                         Gi1/1/1, Gi1/1/2, Te1/1/3 
                                                 Te1/1/4 
10   PCs                              active     Gi1/0/7, Gi1/0/8, Gi1/0/9 
                                                 Gi1/0/12, Gi1/0/13 
20   Phones                          active      Gi1/0/14 
99   Guest                           active      Gi1/0/15, Gi1/0/1 
1002 fddi-default                    act/unsup 
1003 token-ring-default              act/unsup 
1004 fddinet-default                 act/unsup 
1005 trnet-default                   act/unsup 
! This section displays the system wide MTU setting for all 1Gbps and faster ! interfaces 

VLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2
---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ----- 

VLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2
---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ----- 
1    enet  100001     1500  -      -      -        -    -        0      0 
10   enet  100010     1500  -      -      -        -    -        0      0 
20   enet  100020     1500  -      -      -        -    -        0      0 
99   enet  100099     1500  -      -      -        -    -        0      0 
1002 fddi  101002     1500  -      -      -        -    -        0      0 
1003 tr    101003     1500  -      -      -        -    -        0      0 
1004 fdnet 101004     1500  -      -      -        ieee -        0      0 
1005 trnet 101005     1500  -      -      -        ibm  -        0      0

If a Remote SPAN VLAN is configured, it will be displayed in this section. 
! Remote SPAN VLANs are explained in Chapter 24 
Remote SPAN VLANs
----------------------------------------------------------------------------- 
! If Private VLANs are configured, they will be displayed in this section. 
! Private VLANs are outside of the scope of this book, but more information 
! can be found at http://www.cisco.com 
Primary Secondary                     Type Ports
------- --------- ----------------- -----------------------------------------
```

Las **palabras clave opcionales** del comando **`show vlan`** proporcionan los siguientes beneficios:

- **`brief`**: muestra únicamente las asignaciones relevantes de **puerto a VLAN**.
    
- **`summary`**: muestra un conteo de VLANs, las VLANs que participan en **VTP**, y las VLANs que se encuentran en el **rango extendido**.
    
- **`id vlan-id`**: muestra toda la salida del comando original, pero filtrada únicamente a la **VLAN especificada por número**.
    
- **`name vlan-name`**: muestra toda la salida del comando original, pero filtrada únicamente a la **VLAN especificada por nombre**.
    

El **Ejemplo 1-3** muestra el uso de las palabras clave opcionales. Observa que la salida del comando **`id vlan-id`** es la misma que la salida del comando **`name vlan-name`**.

**Ejemplo 1-3** ** Uso de las palabras clave opcionales del comando `show vlan`
```
SW1# show vlan brief 
VLAN  Name                            Status    Ports
---- -------------------------------- --------- ------------------------------ 
1    default                          active    Gi1/0/1, Gi1/0/2, Gi1/0/3 
                                                Gi1/0/4, Gi1/0/5, Gi1/0/6 
                                                Gi1/0/10, Gi1/0/11, Gi1/0/17
                                                Gi1/0/18, Gi1/0/19, Gi1/0/20
                                                Gi1/0/21, Gi1/0/22, Gi1/0/23
                                                Gi1/1/1, Gi1/1/2, Te1/1/3 
                                                Te1/1/
10   PCs                              active    Gi1/0/7, Gi1/0/8, Gi1/0/9 
                                                Gi1/0/12, Gi1/0/13 
20   Phones                           active    Gi1/0/14 
99   Guest                            active    Gi1/0/15, Gi1/0/16 
1002 fddi-default                     act/unsup 
1003 token-ring-default               act/unsup 
1004 fddinet-default                  act/unsup 
1005 trnet-default                    act/unsup
```
```
SW1# show vlan summary 
Number of existing VLANs                  : 8 
Number of existing VTP VLANs              : 8 
Number of existing extended VLANS         : 0
```
```
SW1# show vlan id 99 
VLAN  Name                            Status    Ports
---- -------------------------------- --------- ------------------------------ 
99   Guest                            active    Gi1/0/15, Gi1/0/16 

VLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2
---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ----- 
99   enet  100099     1500  -      -      -        -    -        0      0 

Remote SPAN VLAN
--------------- 
Disabled 

Primary Secondary Type              Ports
------- --------- ----------------- ----------------------------------------
```
```
SW1# show vlan name guest
VLAN  Name                            Status    Ports
---- -------------------------------- --------- ------------------------------ 
99   Guest                            active    Gi1/0/15, Gi1/0/16 

VLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2
---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ----- 
99   enet  100099     1500  -      -      -        -    -        0      0 

Remote SPAN VLAN
--------------- 
Disabled 

Primary Secondary Type              Ports
------- --------- ----------------- ----------------------------------------
```

### Puertos de acceso

Los **puertos de acceso** son los bloques fundamentales de construcción de un switch. Un puerto de acceso se asigna a **una sola VLAN**. Transporta tráfico desde la VLAN especificada hacia el dispositivo conectado o desde el dispositivo hacia otros dispositivos dentro de la misma VLAN en ese switch. Las **etiquetas 802.1Q** no se incluyen en los paquetes transmitidos o recibidos en los puertos de acceso.
Los **switches de acceso Catalyst** configuran los puertos del switch como **puertos de acceso de Capa 2 para la VLAN 1** de forma predeterminada. Un puerto puede configurarse manualmente como puerto de acceso con el comando **`switchport mode access`**. Una VLAN específica se asocia al puerto mediante el comando **`switchport access vlan {vlan-id | name vlan-name}`**. La posibilidad de asignar VLANs a puertos de acceso usando el **nombre** de la VLAN seguirá almacenando la VLAN en **formato numérico** dentro de la configuración.

El **Ejemplo 1-4** demuestra la configuración de los puertos del switch **Gi1/0/15** y **Gi1/0/16** como puertos de acceso en la **VLAN 99** para invitados. Observa que la configuración final se guarda como **números** para ambos puertos, aunque se hayan utilizado comandos distintos.

**Ejemplo 1-4:** Configuración de un puerto de acceso
```
W1# configure terminal 
Enter configuration commands, one per line. End with CNTL/Z. 
SW1(config)# vlan 99 
SW1(config-vlan)# name Guests 
SW1(config-vlan)# interface gi1/0/15 
SW1(config-if)# switchport mode access 
SW1(config-if)# switchport access vlan 99 
SW1(config-if)# interface gi1/0/16 
SW1(config-if)# switchport mode access 
SW1(config-if)# switchport access vlan name Guest
```
```
SW1# show running-config | begin interface GigabitEthernet1/0/15 
interface GigabitEthernet1/0/15 
  switchport access vlan 99 
  switchport mode access 
! 
interface GigabitEthernet1/0/16 
  switchport access vlan 99 
  switchport mode access
```

### Puertos troncales

Los **puertos troncales** pueden transportar **múltiples VLANs**. Normalmente se utilizan cuando varias VLANs necesitan conectividad entre un switch y otro switch, router o firewall utilizando **un solo puerto**. Cuando el paquete se recibe en el enlace remoto del troncal, se examinan los encabezados, el tráfico se asocia con la VLAN correcta, se eliminan los encabezados **802.1Q** y el tráfico se reenvía al siguiente puerto según la **dirección MAC** de esa VLAN.

> **Nota:** Gracias a la introducción de la **virtualización**, algunos servidores ejecutan un **hipervisor** para el sistema operativo y contienen un **switch virtualizado** con diferentes VLANs. Estos servidores también proporcionan conectividad mediante un **puerto troncal**.

Los puertos troncales se definen de forma estática en los switches **Catalyst** mediante el comando de interfaz **`switchport mode trunk`**. En el **Ejemplo 1-5**, las interfaces **Gi1/0/2** y **Gi1/0/3** se convierten en puertos troncales.

**Ejemplo 1-5:** Configuración de un puerto troncal
```
W1# configure terminal 
Enter configuration commands, one per line. End with CNTL/Z. 
SW1(config)# interface gi1/0/2 
SW1(config-if)# switchport mode trunk 
SW1(config-if)# interface gi1/0/3 
SW1(config-if)# switchport mode trunk
```

El **Ejemplo 1-6** muestra la salida del comando **`show interfaces trunk`**. Este comando proporciona mucha información útil, organizada en varias secciones, para la **resolución de problemas de conectividad** entre dispositivos de red:

- La **primera sección** enumera todas las interfaces que son **puertos troncales**, su **estado** y cuál VLAN es la **VLAN nativa** de ese puerto troncal. Las VLAN nativas se explican en la siguiente sección. Las interfaces **EtherChannel** se explican en el Capítulo 5, _“VLAN Trunks and EtherChannel Bundles”_.
    
- La **segunda sección** de la salida muestra la lista de **VLANs permitidas** en el puerto troncal. El tráfico puede minimizarse en los puertos troncales restringiendo las VLANs permitidas a switches específicos, reduciendo así el tráfico broadcast. Otros casos de uso implican una forma de **balanceo de carga** entre enlaces de red, donde se seleccionan VLANs específicas permitidas en un enlace troncal, mientras que un conjunto diferente de VLANs se permite en otro puerto troncal.
    
- La **tercera sección** muestra las VLANs que se encuentran en **estado de reenvío (forwarding)** en el switch. Los puertos que están en **estado de bloqueo (blocking)** no se listan en esta sección.
    

**Ejemplo 1-6:** Verificación del estado de un puerto troncal
```
SW1# show interfaces trunk 
! Section 1 displays the physical or EtherChannel interface status, encapsulation, 
! and native VLAN associated to the interface 

Port        Mode            Encapsulation   Status        Native vlan 
Gi1/0/2     on              802.1q          trunking      1  
Gi1/0/3     on              802.1q          trunking      1 

! Section 2 displays all of the VLANs that are allowed to be transmitted across  
! the trunk ports 

Port        Vlans allowed on trunk 
Gi1/0/2     1-4094 
Gi1/0/3     1-4094 

Port        Vlans allowed and active in management domain 
Gi1/0/2     1,10,20,99 
Gi1/0/3     1,10,20,99

! Section 3 displays all of the VLANs that are allowed across the trunk and are 
! in a spanning tree forwarding state 

Port        Vlans in spanning tree forwarding state and not pruned 
Gi1/0/2     1,10,20,99 
Gi1/0/3     1,10,20,99
```

### VLAN nativa

En el estándar **802.1Q**, cualquier tráfico que se transmite o se recibe en un **puerto troncal** sin la etiqueta 802.1Q se asocia a la **VLAN nativa**. Todo el tráfico asociado a la VLAN nativa fluye a través del puerto troncal **sin etiquetar (untagged)**. La VLAN nativa predeterminada es la **VLAN 1**.

La **VLAN nativa** es una configuración a nivel de **puerto** y se modifica mediante el comando de interfaz **`switchport trunk native vlan vlan-id`**.

> **Nota:** Dos hosts en la misma subred aún podrían comunicarse si un host está conectado a un puerto de acceso asociado a **VLAN 10** y el otro host se conecta a un puerto troncal configurado con **VLAN nativa 10**. Esta no es una buena práctica, pero demuestra que no se agrega una etiqueta VLAN 802.1Q al paquete en ninguno de los dos puertos.

> **Nota:** Todo el tráfico del **plano de control** del switch se anuncia usando la **VLAN 1**. Las guías de endurecimiento de seguridad de Cisco recomiendan cambiar la VLAN nativa a un valor distinto de VLAN 1. Más específicamente, debe configurarse en una VLAN que **no se utilice en absoluto** (es decir, que no tenga hosts conectados). La VLAN nativa debe **coincidir en ambos extremos** del enlace troncal para que el tráfico pueda transmitirse correctamente a través de dicho enlace.
### VLANs permitidas

Como se indicó anteriormente, las VLANs pueden **restringirse en ciertos puertos troncales** como método de **ingeniería de tráfico**. Esta restricción puede causar problemas si dos hosts que se espera que se comuniquen deben atravesar un enlace troncal y la VLAN no está permitida en dicho puerto troncal. Restringir VLANs podría limitar el **flooding de direcciones MAC** a switches que no tienen hosts conectados a las VLANs restringidas.

El comando de interfaz **`switchport trunk allowed vlan vlan-id(s)`** especifica qué VLANs están permitidas para atravesar el enlace troncal. El **Ejemplo 1-7** muestra una configuración de ejemplo para limitar las VLANs que pueden atravesar el puerto troncal **Gi1/0/2** a las VLANs **1, 10, 20 y 99**.

**Ejemplo 1-7:** Visualización de las VLANs permitidas en un enlace troncal
```
SW1# show run interface gi1/0/1 
interface GigabitEthernet1/0/1 
switchport trunk allowed vlan 1,10,20,99 
switchport mode trunk
```

La **sintaxis completa del comando** **`switchport trunk allowed vlan {vlan-ids | all | none | add vlan-ids | remove vlan-ids | except vlan-ids}`** proporciona una gran potencia en un solo comando.  
La palabra clave opcional **`all`** permite todas las VLANs, mientras que **`none`** elimina todas las VLANs del enlace troncal. La palabra clave **`add`** agrega VLANs adicionales a las que ya están listadas, y la palabra clave **`remove`** elimina la VLAN especificada de las VLANs ya identificadas para ese enlace troncal.

> **Nota:** Al realizar cambios de configuración mediante **scripts**, es recomendable usar las palabras clave **`add`** y **`remove`**, ya que son más descriptivas. Un error común es usar el comando **`switchport trunk allowed vlan vlan-ids`** para listar solo la VLAN que se está agregando. Esto provoca que la lista actual se **sobrescriba**, causando pérdida de tráfico para las VLANs que fueron omitidas.
### Comandos de diagnóstico de Capa 2

La información presentada anteriormente en la sección **“Reenvío en la Capa 2”** proporciona una introducción breve sobre el funcionamiento de un switch. Las siguientes secciones describen algunos **comandos de diagnóstico comunes** que se utilizan en la administración diaria, operación y **resolución de problemas** de una red.
### Tabla de direcciones MAC

La **tabla de direcciones MAC** es responsable de identificar los **puertos del switch** y las **VLANs** con las que está asociado un dispositivo. Un switch construye la tabla de direcciones MAC examinando la **dirección MAC de origen** del tráfico que recibe. Esta información se mantiene para reducir el tamaño del **dominio de colisión** (comunicación punto a punto entre dispositivos y switches) y disminuir la cantidad de **flooding de unicast desconocido**.

La tabla de direcciones MAC puede visualizarse con el comando  
**`show mac address-table [address mac-address | dynamic | vlan vlan-id]`**.  
Las palabras clave opcionales de este comando proporcionan los siguientes beneficios:

- **`address mac-address`**: muestra las entradas que coinciden con la **dirección MAC específica**. Este comando puede ser útil en switches con cientos de puertos.
    
- **`dynamic`**: muestra las entradas que se aprenden **dinámicamente** y que no están configuradas de forma estática ni “quemadas” en el switch.
    
- **`vlan vlan-id`**: muestra las entradas que coinciden con la **VLAN especificada**.
    

El **Ejemplo 1-8** muestra la tabla de direcciones MAC en un switch **Catalyst**. El comando de este ejemplo muestra la VLAN, la dirección MAC, el tipo y el puerto asociado a los dispositivos de red conectados. Observa que el puerto **Gi1/0/3** tiene múltiples entradas, lo que indica que ese puerto está conectado a otro **switch**.

**Ejemplo 1-8:** Visualización de la tabla de direcciones MAC
```
SW1# show mac address-table dynamic 
            Mac Address Table 
Vlan Mac Address          Type            Ports
---- -----------          --------        ---- 
1    0081.c4ff.8b01       DYNAMIC         Gi1/0/2 
1    189c.5d11.9981       DYNAMIC         Gi1/0/3 
1    189c.5d11.99c7       DYNAMIC         Gi1/0/3 
1    7070.8bcf.f828       DYNAMIC         Gi1/0/17 
1    70df.2f22.b882       DYNAMIC         Gi1/0/2 
1    70df.2f22.b883       DYNAMIC         Gi1/0/3 
1    bc67.1c5c.9304       DYNAMIC         Gi1/0/2 
1    bc67.1c5c.9347       DYNAMIC         Gi1/0/3 
99   189c.5d11.9981       DYNAMIC         Gi1/0/3 
99   7069.5ad4.c228       DYNAMIC         Gi1/0/15 
10   0087.31ba.3980       DYNAMIC         Gi1/0/9 
10   0087.31ba.3981       DYNAMIC         Gi1/0/9 
10   189c.5d11.9981       DYNAMIC         Gi1/0/3 
10   3462.8800.6921       DYNAMIC         Gi1/0/8 
10   5067.ae2f.6480       DYNAMIC         Gi1/0/7 
10   7069.5ad4.c220       DYNAMIC         Gi1/0/13 
10   e8ed.f3aa.7b98       DYNAMIC         Gi1/0/12 
20   189c.5d11.9981       DYNAMIC         Gi1/0/3 
20   7069.5ad4.c221       DYNAMIC         Gi1/0/14 

Total Mac Addresses for this criterion: 19
```

> **Nota:** La **resolución de problemas de tráfico de red** desde una perspectiva de **Capa 2** implica localizar el **dispositivo de origen y de destino**, así como el **puerto**. Esta tarea puede realizarse examinando la **tabla de direcciones MAC**. Si aparecen **múltiples direcciones MAC** en el mismo puerto, se puede inferir que un **switch, hub o servidor con un switch virtual** está conectado a ese puerto del switch. Puede ser necesario conectarse a los switches **aguas abajo** para identificar el puerto al que está conectado un dispositivo de red específico.

Algunas tecnologías antiguas (como el **balanceo de carga**) requieren una **entrada MAC estática** en la tabla de direcciones MAC para evitar el flooding de unicast desconocido. El comando de configuración global  
**`mac address-table static mac-address vlan vlan-id {drop | interface interface-id}`**  
agrega una entrada manual, con la posibilidad de asociarla a un puerto específico del switch o de **descartar el tráfico** cuando se reciba.

El comando **`clear mac address-table dynamic [address mac-address | interface interface-id | vlan vlan-id]`** vacía la **tabla de direcciones MAC** de todo el switch. El uso de las palabras clave opcionales permite limpiar la tabla de direcciones MAC para una **dirección MAC específica**, un **puerto del switch** o una **interfaz** concreta.

La tabla de direcciones MAC reside en la **memoria direccionable por contenido (CAM)**. La memoria CAM utiliza **memoria de alta velocidad**, que es más rápida que la memoria RAM típica de un computador, gracias a sus técnicas de búsqueda. La CAM proporciona un **resultado binario** para cualquier consulta (0 para falso o 1 para verdadero). La CAM se utiliza junto con otras funciones para **analizar y reenviar paquetes muy rápidamente**. Los switches están diseñados con CAM para alojar todos los hosts de **Capa 2** para los cuales deben mantener tablas de reenvío.
### Estado de los puertos del switch

Examinar la configuración de un puerto del switch puede ser útil; sin embargo, algunos comandos que se almacenan en otras partes de la configuración **prevalecen sobre la configuración establecida en la interfaz**. El comando **`show interfaces interface-id switchport`** proporciona toda la información relevante sobre el **estado de un puerto del switch**. El comando **`show interfaces switchport`** muestra los mismos parámetros operativos para **todos los puertos del switch**.

El **Ejemplo 1-9** muestra la salida del comando **`show interfaces gi1/0/5 switchport`** en **SW1**. Los campos clave que deben examinarse en este punto son el **estado del puerto**, el **modo operativo** y la **VLAN de acceso**.

**Ejemplo 1-9:** Visualización del estado del puerto del switch
```
SW1# show interfaces gi1/0/5 switchport 
Name: Gi1/0/5 
! The following line indicates if the port is configured as an L2 switchport.
Switchport: Enabled 
Administrative Mode: dynamic auto 
! The following line indicates if the port is acting as static access port, trunk 
! port, or if is down due to carrier detection (i.e. link down) 
Operational Mode: down 
Administrative Trunking Encapsulation: dot1q 
Negotiation of Trunking: On 
! The following line displays the VLAN assigned to the access port 
Access Mode VLAN: 1 (default) 
Trunking Native Mode VLAN: 1 (default) 
Administrative Native VLAN tagging: enabled 
Voice VLAN: none 
Administrative private-vlan host-association: none 
Administrative private-vlan mapping: none 
Administrative private-vlan trunk native VLAN: none 
Administrative private-vlan trunk Native VLAN tagging: enabled 
Administrative private-vlan trunk encapsulation: dot1q 
Administrative private-vlan trunk normal VLANs: none 
Administrative private-vlan trunk associations: none
Administrative private-vlan trunk mappings: none 
Operational private-vlan: none 
Trunking VLANs Enabled: ALL 
Pruning VLANs Enabled: 2-1001 
Capture Mode Disabled 
Capture VLANs Allowed: ALL 

Protected: false 
Unknown unicast blocked: disabled 
Unknown multicast blocked: disabled 
Appliance trust: none
```

### Estado de la interfaz

El comando **`show interfaces status`** es útil para visualizar el estado de los puertos del switch de forma **condensada y simplificada**. El **Ejemplo 1-10** demuestra el uso de este comando e incluye los siguientes campos en la salida:

- **Port**: muestra el **ID de la interfaz** o del **canal de puertos**.
    
- **Name**: muestra la **descripción configurada** de la interfaz.
    
- **Status**: muestra **connected** cuando se detecta una conexión y el enlace está activo. Muestra **notconnect** cuando no se detecta un enlace y **err-disabled** cuando se ha detectado un error y el switch ha deshabilitado la capacidad de reenviar tráfico por ese puerto.
    
- **VLAN**: muestra la **VLAN asignada** para los puertos de acceso. Los enlaces troncales aparecen como **trunk**, y los puertos configurados como interfaces de **Capa 3** se muestran como **routed**.
    
- **Duplex**: muestra el **dúplex** del puerto. Si el dúplex fue **autonegociado**, aparece precedido por **a-**.
    
- **Speed**: muestra la **velocidad** del puerto. Si la velocidad fue **autonegociada**, aparece precedida por **a-**.
    
- **Type**: muestra el **tipo de interfaz** del puerto del switch. Si es un puerto de cobre RJ-45 fijo, incluye **TX** en la descripción (por ejemplo, _10/100/1000BASE-TX_). Los puertos **SFP** aparecen listados con el modelo SFP si el controlador está disponible en el software; de lo contrario, se muestra **unknown**.
    

**Ejemplo 1-10:** Visualización del estado general de las interfaces
```
SW1# show interface status 

Port      Name           Status        Vlan     Duplex    Speed   Type 
Gi1/0/1                  notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/2   SW-2 Gi1/0/1   connected     trunk    a-full    a-1000  10/100/1000BaseTX
Gi1/0/3   SW-3 Gi1/0/1   connected     trunk    a-full    a-1000  10/100/1000BaseTX 
Gi1/0/4                  notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/5                  notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/6                  notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/7   Cube13.C       connected     10       a-full    a-1000  10/100/1000BaseTX 
Gi1/0/8   Cube11.F       connected     10       a-full    a-1000  10/100/1000BaseTX 
Gi1/0/9   Cube10.A       connected     10       a-full    a-100   10/100/1000BaseTX 
Gi1/0/10                 notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/11                 notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/12  Cube14.D Phone connected     10       a-full    a-1000  10/100/1000BaseTX 
Gi1/0/13  R1-G0/0/0      connected     10       a-full    a-1000  10/100/1000BaseTX 
Gi1/0/14  R2-G0/0/1      connected     20       a-full    a-1000  10/100/1000BaseTX 
Gi1/0/15  R3-G0/1/0      connected     99       a-full    a-1000  10/100/1000BaseTX 
Gi1/0/16  R4-G0/1/1      connected     99       a-full    a-1000  10/100/1000BaseTX 
Gi1/0/17                 connected     1        a-full    a-1000  10/100/1000BaseTX 
Gi1/0/18                 notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/19                 notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/20                 notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/21                 notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/22                 notconnect    1        auto      auto    10/100/1000BaseTX 
Gi1/0/23                 notconnect    routed   auto      auto    10/100/1000BaseTX 
Gi1/0/24                 disabled      4011     auto      auto    10/100/1000BaseTX 
Te1/1/1                  notconnect    1        full      10G     SFP-10GBase-SR 
Te1/1/2                  notconnect    1        auto      auto    unknown
```

### Reenvío en la Capa 3

Ahora que hemos revisado los mecanismos de un switch y cómo reenvía tráfico de **Capa 2**, repasemos el proceso de reenvío de un paquete desde una **perspectiva de Capa 3**. Recuerda que todo el tráfico comienza en la **Capa 7** y desciende hasta la **Capa 1** en el dispositivo de origen, por lo que el **reenvío en Capa 3** ocurre **antes** del reenvío en Capa 2. Existen **dos metodologías principales** para el reenvío en Capa 3:

- Reenvío de tráfico a dispositivos que se encuentran en la **misma subred**.
    
- Reenvío de tráfico a dispositivos que se encuentran en una **subred diferente**.
    

Las siguientes secciones explican estas dos metodologías.
### Reenvío en la red local

Dos dispositivos que residen en la **misma subred** se comunican de forma local. A medida que se construyen los encabezados del paquete, el dispositivo detecta que la **dirección de destino** está en la misma red. Sin embargo, el **enrutamiento real** ocurre todavía en **Capa 2**, ya que la **dirección MAC de destino** se utiliza en los encabezados. El dispositivo conoce su **propia dirección MAC**, pero inicialmente **no conoce la dirección MAC del destino**.

La **tabla del Protocolo de Resolución de Direcciones (ARP)** proporciona un método para **mapear direcciones IP de Capa 3 a direcciones MAC de Capa 2**, almacenando la dirección IP de un host junto con su dirección MAC correspondiente. El dispositivo utiliza la tabla ARP para agregar los encabezados adecuados de Capa 2 al paquete de datos antes de enviarlo a través del modelo OSI para su procesamiento y reenvío.

Por ejemplo, si un host IP necesita comunicarse con otro host IP dentro del mismo segmento de **Capa 2** (mismo dominio de broadcast) y **no existe una entrada ARP** para el otro host en la tabla ARP local, el host IP realiza la resolución de direcciones **difundiendo (broadcast)** una **solicitud ARP** a todo el segmento de Capa 2. La solicitud ARP pregunta específicamente **quién es el propietario** de la dirección IP de destino. Todos los hosts del segmento reciben la solicitud, pero **solo** el host cuya IP coincide debe responder.

El host que responde genera una **respuesta ARP unicast** que incluye la **dirección IP y la dirección MAC** solicitadas. El host solicitante recibe la respuesta ARP y **actualiza su tabla ARP local**. Ahora, el host puede agregar los encabezados correctos de Capa 2 y enviar el paquete de datos original para su procesamiento y reenvío.

La **tabla ARP** contiene entradas de hosts o dispositivos de red con los que el host se ha comunicado **recientemente** y que están en el **mismo segmento IP**. No contiene entradas para dispositivos en una red remota, pero sí incluye una entrada ARP para la **dirección IP del siguiente salto (next hop)** utilizada para alcanzar la red remota. Si no ocurre comunicación con un host durante un período prolongado, la entrada se considera **obsoleta** y se elimina de la tabla ARP local.

> **Nota:** La tabla ARP puede visualizarse con el comando  
**`show ip arp [mac-address | ip-address | vlan vlan-id | interface-id]`**.  
Las palabras clave opcionales permiten **filtrar** la información mostrada.
### Enrutamiento de paquetes

Los paquetes deben **enrutarse** cuando dos dispositivos están en **redes diferentes**. A medida que los datos se encapsulan con su dirección IP, el dispositivo detecta que el destino está en una **red distinta** y que el tráfico debe ser enrutado. El dispositivo consulta su **tabla de enrutamiento local** para identificar la **dirección IP del siguiente salto**, la cual puede aprenderse de varias maneras:

- A partir de una **ruta estática**, que proporciona la red de destino, la máscara de subred y la IP del siguiente salto.
    
- Mediante una **puerta de enlace predeterminada**, que es una ruta estática simplificada utilizada para todo el tráfico no local.
    
- A través de **protocolos de enrutamiento dinámico**.
    

El dispositivo de origen debe agregar los **encabezados adecuados de Capa 2** (direcciones MAC de origen y destino), pero la **dirección MAC de destino** debe corresponder a la **IP del siguiente salto**. El dispositivo busca la IP del siguiente salto en la **tabla ARP** y utiliza la dirección MAC asociada. Los encabezados del paquete se agregan y, finalmente, el paquete se envía a la **Capa 1** para su procesamiento y reenvío.

El **router de siguiente salto** recibe el paquete basándose en la **dirección MAC de destino**, analiza la **dirección IP de destino**, localiza la **red adecuada** en su **tabla de enrutamiento**, identifica la **interfaz de salida** y luego encuentra la **dirección MAC** del dispositivo de destino (o la dirección MAC del siguiente salto si el paquete debe seguir siendo enrutado). A continuación, el router **modifica la dirección MAC de origen** por la **dirección MAC de su interfaz de salida** y **modifica la dirección MAC de destino** por la **dirección MAC del dispositivo de destino** (o del siguiente router de siguiente salto).

La **Figura 1-5** ilustra el concepto, con **PC-A** enviando un paquete a **PC-B** a través de una conexión Ethernet hacia **R1**. **PC-A** envía el paquete a la **dirección MAC de R1 (00:C1:5C:00:00:A1)**. **R1** recibe el paquete, **elimina la información de Capa 2** y examina la información de **Capa 3** para determinar que **192.168.2.2** es el destino final y que la conectividad debe realizarse a través de la interfaz **GigabitEthernet 0/1** de R1. R1 vuelve a **agregar los encabezados de Capa 2** utilizando su **dirección MAC de GigabitEthernet 0/1 (00:C1:5C:00:00:B1)** y la **dirección MAC de destino (00:00:00:BB:BB:BB)** correspondiente a **PC-B**.

![[img/Pasted image 20251230120051.png]]

**Nota:** Este proceso continúa tantas veces como sea necesario para llevar el paquete desde el **dispositivo de origen** hasta el **dispositivo de destino**.
### Asignación de direcciones IP

**TCP/IP** se ha convertido en el **protocolo estándar** para la mayoría de las redes. Inicialmente, se utilizó con **IPv4** y direcciones de red de **32 bits**. El número de dispositivos que utilizan direcciones IP públicas ha crecido de forma **exponencial**, lo que agotó el conjunto de direcciones IPv4 disponibles públicamente.

Para afrontar el aumento de la demanda de direcciones públicas, en **1998** se desarrolló un segundo estándar, llamado **IPv6**, que proporciona **direccionamiento de 128 bits**. Se han creado tecnologías y mecanismos que permiten que redes **IPv4 e IPv6** se comuniquen entre sí. Con cualquiera de las dos versiones, una **dirección IP debe asignarse a una interfaz** de un **router** o de un **switch multicapa** para poder **enrutar paquetes**.

Las **direcciones IPv4** se asignan mediante el comando de configuración de interfaz  
**`ip address ip-address subnet-mask`**. Una interfaz con una dirección IP configurada y en estado operativo **“up”** crea una **ruta conectada** asociada a esa red dentro de la **Base de Información de Enrutamiento (RIB)** del router. Las rutas conectadas tienen una **distancia administrativa (AD) de cero**, lo que hace posible que cualquier protocolo de enrutamiento estático o dinámico **reemplace** una ruta conectada en la RIB.

Es posible **asociar múltiples redes IPv4** a la misma interfaz configurando una **dirección IPv4 secundaria** en esa interfaz mediante el comando  
**`ip address ip-address subnet-mask secondary`**.

Las **direcciones IPv6** se asignan mediante el comando de configuración de interfaz  
**`ipv6 address ipv6-address/prefix-length`**. Este comando puede repetirse varias veces para agregar **múltiples direcciones IPv6** a la misma interfaz.

El **Ejemplo 1-11** demuestra la configuración de direcciones IP en **interfaces enrutadas**. Una interfaz enrutada es, básicamente, una interfaz en un router. Observa que agregar una **segunda dirección IPv4** requiere el uso de la palabra clave **`secondary`**, mientras que el comando **`ipv6 address`** puede utilizarse varias veces para configurar múltiples direcciones IPv6.

**Ejemplo 1-11:** Asignación de direcciones IP a interfaces enrutadas
```
R1# configure terminal
Enter configuration commands, one per line. End with CNTL/Z.
R1(config)# interface gi0/0
R1(config-if)# ip address 10.10.10.254 255.255.255.0
R1(config-if)# ip address 172.16.10.254 255.255.255.0 secondary
R1(config-if)# ipv6 address 2001:db8:10::254/64
R1(config-if)# ipv6 address 2001:db8:10:172::254/64
R1(config-if)# interface gi0/1
R1(config-if)# ip address 10.20.20.254 255.255.255.0
R1(config-if)# ip address 172.16.20.254 255.255.255.0 secondary
R1(config-if)# ipv6 address 2001:db8:20::254/64
R1(config-if)# ipv6 address 2001:db8:20:172::254/64
```

### Subinterfaces enrutadas

Se requiere una **subinterfaz enrutada** cuando existen **múltiples VLANs** en un switch que necesitan **enrutamiento**, y no es deseable usar una **interfaz física dedicada** del router para cada VLAN, o cuando no hay suficientes interfaces físicas disponibles para acomodar todas las VLANs. Para solucionar esto, es posible crear un **puerto troncal** en el switch y crear **subinterfaces lógicas** en el router.

Una subinterfaz se crea **agregando un punto y un valor numérico** después del número de la interfaz física. Luego, la **VLAN** debe asociarse a la subinterfaz con el comando **`encapsulation dot1q vlan-id`**.

El **Ejemplo 1-12** muestra la configuración de **dos subinterfaces** en **R2**. El **número de la subinterfaz** no tiene que coincidir con el **ID de la VLAN**, pero si coincide, facilita el **soporte operativo**.

**Ejemplo 1-12:** Configuración de subinterfaces enrutadas
```
R2# configure terminal
Enter configuration commands, one per line. End with CNTL/Z.
R2(config)# int gi0/0/1.10
R2(config-subif)# encapsulation dot1q 10
R2(config-subif)# ip address 10.10.10.2 255.255.255.0
R2(config-subif)# ipv6 address 2001:db8:10::2/64
R2(config)# int gi0/0/1.99
R2(config-subif)# encapsulation dot1q 99
R2(config-subif)# ip address 10.20.20.2 255.255.255.0
R2(config-subif)# ipv6 address 2001:db8:20::2/64
```

### Interfaces virtuales conmutadas

En los **switches Catalyst**, es posible asignar una **dirección IP** a una **interfaz virtual conmutada (SVI)**, también conocida como **interfaz VLAN**. Una SVI se configura definiendo la **VLAN en el switch** y luego definiendo la **interfaz VLAN** con el comando **`interface vlan vlan-id`**. El switch debe tener una **interfaz asociada a esa VLAN en estado up** para que la SVI también esté en estado **up**.

Si el switch es un **switch multicapa**, las SVIs pueden utilizarse para **enrutar paquetes entre VLANs** sin necesidad de un router externo.

El **Ejemplo 1-13** demuestra la configuración de la **SVI** para las **VLANs 10 y 99**.

**Ejemplo 1-13:** Creación de una interfaz virtual conmutada (SVI)
```
SW1# configure terminal
Enter configuration commands, one per line. End with CNTL/Z.
SW1(config)# interface vlan 10
SW1(config-if)# ip address 10.10.10.1 255.255.255.0
SW1(config-if)# ipv6 address 2001:db8:10::1/64
SW1(config-if)# no shutdown
SW1(config)# interface vlan 99
SW1(config-if)# ip address 10.99.99.1 255.255.255.0
SW1(config-if)# ipv6 address 2001:db8:99::1/64
SW1(config-if)# no shutdown
```

### Puertos de switch enrutados

Algunos diseños de red incluyen un **enlace punto a punto** entre switches para realizar **enrutamiento**. Por ejemplo, cuando un switch necesita conectarse a un router, algunos ingenieros de red crean una **VLAN de tránsito** (por ejemplo, **VLAN 2001**), asocian el puerto que conecta al router a esa VLAN y luego crean una SVI para la VLAN 2001. Siempre existe la posibilidad de que una VLAN 2001 no utilizada pueda existir en el **reino de Capa 2**, o que un **árbol de expansión (STP)** impacte la topología.

En su lugar, un **puerto de switch multicapa** puede convertirse de un **puerto de Capa 2** a un **puerto enrutado** mediante el comando de configuración de interfaz **`no switchport`**. Luego se puede asignar una **dirección IP** a dicho puerto. El **Ejemplo 1-14** muestra cómo **Gi1/0/14** se convierte de un puerto de switch de Capa 2 a un **puerto enrutado** y cómo se le asigna una dirección IP.

**Ejemplo 1-14:** Configuración de un puerto de switch enrutado
```
SW1# configure terminal
Enter configuration commands, one per line. End with CNTL/Z.
SW1(config)# int gi1/0/14
SW1(config-if)# no switchport
SW1(config-if)# ip address 10.20.20.1 255.255.255.0
SW1(config-if)# ipv6 address 2001:db8:20::1/64
SW1(config-if)# no shutdown
```

### Verificación de direcciones IP

Las direcciones **IPv4** pueden visualizarse con el comando  
**`show ip interface brief [interface-id | vlan-id]`**.  
La salida de este comando contiene mucha información útil, como **MTU**, **retraso**, **relé DHCP**, **ACLs** y la **dirección IP principal**. La palabra clave opcional **`brief`** muestra la salida en un formato **condensado**.

Sin embargo, en dispositivos con una gran cantidad de puertos, el uso del **parser de la CLI** y la adición de filtros de exclusión (por ejemplo, **`unassigned`**) produce una vista más clara de las interfaces que **sí** tienen direcciones IP configuradas.

El **Ejemplo 1-15** muestra el comando **`show ip interface brief`** utilizado **con y sin** el parser de la CLI. Observa la **reducción drástica** de datos innecesarios que se presentan.

**Ejemplo 1-15:** Visualización de direcciones IPv4 en el dispositivo
```
SW1# show ip interface brief
Interface              IP-Address      OK? Method Status  Protocol
Vlan1                  unassigned      YES manual up      up
Vlan10                 10.10.10.1      YES manual up      up
Vlan99                 10.99.99.1      YES manual up      up
GigabitEthernet1/0/0   unassigned      YES unset  down    down
GigabitEthernet1/0/1   unassigned      YES unset  down    down
GigabitEthernet1/0/2   unassigned      YES unset  up      up
GigabitEthernet1/0/3   unassigned      YES unset  up      up
GigabitEthernet1/0/4   unassigned      YES unset  down    down
GigabitEthernet1/0/5   unassigned      YES unset  down    down
GigabitEthernet1/0/6   unassigned      YES unset  down    down
GigabitEthernet1/0/7   unassigned      YES unset  up      up
GigabitEthernet1/0/8   unassigned      YES unset  up      up
GigabitEthernet1/0/9   unassigned      YES unset  up      up
GigabitEthernet1/0/10  unassigned      YES unset  down    down
GigabitEthernet1/0/11  unassigned      YES unset  down    down
GigabitEthernet1/0/12  unassigned      YES unset  down    down
GigabitEthernet1/0/13  unassigned      YES unset  up      up
GigabitEthernet1/0/14  10.20.20.1      YES manual up      up
GigabitEthernet1/0/15  unassigned      YES unset  up      up
GigabitEthernet1/0/16  unassigned      YES unset  up      up
GigabitEthernet1/0/17  unassigned      YES unset  down    down
```
```
SW1# show ip interface brief | exclude unassigned
Interface              IP-Address      OK? Method Status  Protocol
Vlan10                 10.10.10.1      YES manual up      up
Vlan99                 10.99.99.1      YES manual up      up
GigabitEthernet1/0/14  10.20.20.1      YES manual up      up
GigabitEthernet1/0/23  192.168.1.1     YES manual down    down
```

La **misma información** también puede visualizarse para **direcciones IPv6** mediante el comando  
**`show ipv6 interface brief [interface-id | vlan vlan-id]`**.  
Al igual que con IPv4, se puede utilizar el **parser de la CLI** para **reducir la información** a lo que realmente es relevante, como se demuestra en el **Ejemplo 1-16**.

**Ejemplo 1-16:** Visualización de direcciones IPv6 en el dispositivo
```
SW1# show ipv6 interface brief
Output omitted for brevity

Vlan1                 [up/up]
  FE80::262:ECFF:FE9D:C547
  2001:1::1

Vlan10                [up/up]
  FE80::262:ECFF:FE9D:C546
  2001:DB8:10::1

Vlan99                [up/up]
  FE80::262:ECFF:FE9D:C55D
  2001:DB8:99::1

GigabitEthernet1/0/0  [down/down]
  unassigned

GigabitEthernet1/0/1  [down/down]
  unassigned

GigabitEthernet1/0/2  [up/up]
  unassigned

GigabitEthernet1/0/3  [up/up]
  unassigned

GigabitEthernet1/0/4  [down/down]
  unassigned

GigabitEthernet1/0/5  [down/down]
  unassigned
```

Aplicando el **filtro del parser de la CLI** para excluir interfaces sin direcciones IPv6 asignadas:
```
SW1# show ipv6 interface brief | exclude unassigned|GigabitEthernet
Vlan1                 [up/up]
  FE80::262:ECFF:FE9D:C547
  2001:1::1

Vlan10                [up/up]
  FE80::262:ECFF:FE9D:C546
  2001:DB8:10::1

Vlan99                [up/up]
  FE80::262:ECFF:FE9D:C55D
  2001:DB8:99::1
```

Este enfoque permite una **visualización mucho más limpia y operativa**, especialmente en switches con **gran cantidad de interfaces**, donde la señal importante suele quedar enterrada bajo mucho ruido.
### Arquitecturas de reenvío

Los primeros routers Cisco recibían un paquete, eliminaban la información de **Capa 2** y verificaban que existiera una ruta hacia la **dirección IP de destino**. Si no se encontraba una ruta coincidente, el paquete se descartaba. Si se encontraba una ruta válida, el router identificaba y **agregaba un nuevo encabezado de Capa 2** al paquete.

Los avances tecnológicos han simplificado este proceso, de modo que los routers **ya no eliminan y vuelven a agregar** los encabezados de Capa 2, sino que **simplemente reescriben las direcciones**. La **conmutación de paquetes IP** o el **reenvío de paquetes IP** es un proceso más rápido para recibir un paquete IP en una interfaz de entrada y decidir si reenviarlo por una interfaz de salida o descartarlo. Este proceso es simple y eficiente, lo que permite a un router **reenviar grandes volúmenes de paquetes**.

Cuando se desarrollaron los primeros routers Cisco, utilizaban un mecanismo llamado **process switching** para conmutar paquetes a través del router. A medida que los dispositivos de red evolucionaron, Cisco creó **fast switching** y **Cisco Express Forwarding (CEF)** para optimizar el proceso de conmutación y permitir a los routers manejar **mayores volúmenes de tráfico**.
### Conmutación por procesos (Process Switching)

La **conmutación por procesos**, también conocida como **conmutación por software** o **ruta lenta (slow path)**, es un mecanismo de conmutación en el que la **CPU de propósito general** del router se encarga del reenvío de paquetes. En IOS, el proceso **`ip_input`** se ejecuta en la CPU de propósito general para procesar los paquetes IP entrantes. La conmutación por procesos es el **mecanismo de respaldo** de CEF, ya que está dedicada a procesar **paquetes IP desviados (punted)** cuando no pueden ser conmutados por CEF.

Los tipos de paquetes que generalmente requieren **manejo por software** incluyen:

- Paquetes **originados o destinados al router** (por ejemplo, tráfico de control o protocolos de enrutamiento).
    
- Paquetes que son **demasiado complejos** para que el hardware los maneje (por ejemplo, paquetes IP con **opciones IP**).
    
- Paquetes que requieren **información adicional** que no se conoce en ese momento (por ejemplo, **entradas ARP no resueltas**).
    

> **Nota:** La conmutación por software es **significativamente más lenta** que la conmutación realizada en hardware. El proceso **`ip_input`** está diseñado para manejar **un porcentaje muy pequeño del tráfico** gestionado por el sistema. Siempre que sea posible, los paquetes se **conmutan por hardware**.

La **Figura 1-6** ilustra cómo un paquete que no puede ser conmutado por **CEF** se desvía hacia la **CPU** para su procesamiento. El proceso **`ip_input`** consulta la **tabla de enrutamiento** y la **tabla ARP** para obtener la **dirección IP del siguiente salto**, la **interfaz de salida** y las **direcciones MAC**. Luego **reescribe la dirección MAC de destino** del paquete con la dirección MAC del **siguiente router**, **reescribe la dirección MAC de origen** con la dirección MAC de la **interfaz de salida**, **decrementa el TTL (Time To Live)** del encabezado IP, **recalcula la suma de verificación (checksum)** del encabezado IP y, finalmente, **entrega el paquete al router de siguiente salto**.

![[img/Pasted image 20251230121345.png]]

La **tabla de enrutamiento**, también conocida como **Base de Información de Enrutamiento (RIB)**, se construye a partir de información obtenida de **protocolos de enrutamiento dinámico** y de **rutas directamente conectadas y estáticas**. La **tabla ARP** se construye a partir de la información obtenida del **protocolo ARP**.
### Cisco Express Forwarding (CEF)

**Cisco Express Forwarding (CEF)** es un mecanismo de conmutación **propietario de Cisco**, desarrollado para mantenerse al ritmo de las crecientes demandas de las infraestructuras de red modernas. Ha sido el **mecanismo de conmutación predeterminado** en la mayoría de los routers que realizan conmutación de paquetes IP usando la **CPU de propósito general** (routers basados en software) desde la década de 1990, y es también el mecanismo de conmutación predeterminado utilizado por **todas las plataformas Cisco** que emplean **circuitos integrados de aplicación específica (ASICs)** y **unidades de procesamiento de red (NPUs)** para lograr **alto rendimiento de paquetes** (routers basados en hardware).

Las **CPU de propósito general** en routers basados en software y en hardware son similares y realizan las mismas funciones; la diferencia es que, en routers basados en software, la CPU de propósito general se encarga de **todas las operaciones**, incluida la **conmutación CEF** (CEF por software), mientras que en routers basados en hardware, CEF se ejecuta utilizando **motores de reenvío** implementados en **ASICs especializados**, **memoria direccionable por contenido ternario (TCAM)** y **NPUs** (CEF por hardware).

Los **motores de reenvío** proporcionan a los routers la capacidad de **conmutación de paquetes**, **reenvío** y **búsqueda de rutas**.
### Memoria direccionable por contenido ternario

La **memoria direccionable por contenido ternario (TCAM)** de un switch permite la **comparación y evaluación de un paquete en más de un campo**. La TCAM es una extensión de la arquitectura **CAM**, pero mejorada para permitir un procesamiento adecuado, como la identificación de **direcciones de Capa 2/3 de origen y destino**, **protocolos**, **marcados QoS**, entre otros. La TCAM ofrece **mayor flexibilidad** en las búsquedas que la CAM, la cual es binaria. Una búsqueda en TCAM proporciona **tres resultados posibles**: **0** para falso, **1** para verdadero y **X** para “no importa”, lo que constituye una **combinación ternaria**.

Las entradas de TCAM se almacenan en formato **Valor, Máscara y Resultado (VMR)**. El **valor** indica los campos que deben compararse, como la **dirección IP** y los **campos de protocolo**. La **máscara** indica qué campo es de interés y debe utilizarse en la comparación. El **resultado** indica la acción que debe tomarse si existe una coincidencia entre el valor y la máscara. Además de permitir o descartar tráfico, pueden seleccionarse **múltiples acciones**, como **redirigir el flujo** a un **policía de QoS** o especificar un **puntero a otra entrada** dentro de la tabla de reenvío.

La mayoría de los **switches** implementan **múltiples entradas TCAM** para que las decisiones de **seguridad de entrada/salida**, **QoS** y **reenvío de Capa 2 y Capa 3** ocurran **de forma simultánea**. La TCAM opera en **hardware**, proporcionando un procesamiento más rápido y una mayor **escalabilidad** que la conmutación por procesos. Esto permite que algunas funciones, como las **ACL**, se procesen a la **misma velocidad**, independientemente de si existen **10 o 500 entradas**. La TCAM no es un recurso infinito, y **equilibrar la asignación de memoria** entre funciones implica **compromisos (trade-offs)**.
### Reenvío centralizado

Dado el **bajo costo de las CPU de propósito general**, el precio de los routers basados en software se ha vuelto más accesible, pero a costa del **rendimiento total de paquetes**.

Cuando un **procesador de rutas (RP)** está equipado con un **motor de reenvío** capaz de tomar todas las decisiones de conmutación de paquetes, se denomina una **arquitectura de reenvío centralizado**. Si las **tarjetas de línea** están equipadas con motores de reenvío para que puedan tomar decisiones de conmutación de paquetes **sin la intervención del RP**, se denomina una **arquitectura de reenvío distribuido**.

En una arquitectura de **reenvío centralizado**, cuando un paquete se recibe en la **tarjeta de línea de entrada (ingress)**, se transmite al **motor de reenvío** ubicado en el RP. El motor de reenvío examina los **encabezados del paquete** y determina si el paquete se enviará por un **puerto en la tarjeta de línea de salida (egress)**, y luego reenvía el paquete a dicha tarjeta para su envío.
### Reenvío distribuido

En una arquitectura de **reenvío distribuido**, cuando un paquete se recibe en la **tarjeta de línea de entrada**, se envía al **motor de reenvío local** de esa tarjeta. El motor de reenvío realiza una **búsqueda de paquetes** y, si determina que la **interfaz de salida** es local, reenvía el paquete a una **interfaz local**. Si la interfaz de salida se encuentra en una **tarjeta de línea diferente**, el paquete se envía a través de la **matriz de conmutación del switch**, también conocida como el **backplane**, directamente a la **tarjeta de línea de salida**, **evitando pasar por el RP**.

La **Figura 1-7** muestra la diferencia entre las arquitecturas de **reenvío centralizado** y **reenvío distribuido**.
![[img/Pasted image 20251230121548.png]]

### CEF por software

**CEF por software**, también conocido como la **Base de Información de Reenvío (FIB) por software**, consta de los siguientes componentes:

- **Base de Información de Reenvío (FIB)**: la FIB se construye directamente a partir de la **tabla de enrutamiento** y contiene la **dirección IP del siguiente salto** para cada destino en la red. Mantiene una **imagen espejo** de la información de reenvío contenida en la tabla de enrutamiento IP. Cuando ocurre un cambio de enrutamiento o de topología en la red, la tabla de enrutamiento IP se actualiza y esos cambios se **reflejan en la FIB**. CEF utiliza la FIB para tomar decisiones de conmutación IP **basadas en prefijos**.
    
- **Tabla de adyacencias**, también conocida como la **Base de Información de Adyacencias (AIB)**: contiene las **direcciones IP de siguiente salto directamente conectadas** y sus **direcciones MAC de siguiente salto correspondientes**, así como las **direcciones MAC de la interfaz de salida (egress)**. La tabla de adyacencias se **rellena con datos de la tabla ARP** u otras tablas de protocolos de Capa 2.
    

La **Figura 1-8** ilustra cómo la tabla CEF se construye a partir de la tabla de enrutamiento. Primero, la **FIB** se construye a partir de la tabla de enrutamiento. La ruta **172.16.10.0/24** tiene una ruta estática con un siguiente salto **10.40.40.254**, que depende del prefijo **10.40.40.0/24** aprendido vía **OSPF**. La entrada de adyacencia para la ruta **172.16.10.0/24** es exactamente la misma dirección IP que la ruta OSPF para **10.40.40.0/24**, que es **10.40.40.254**. La tabla de adyacencias se construye entonces usando la **tabla ARP** y **correlacionando la dirección MAC** con la **tabla de direcciones MAC** para identificar la **interfaz de salida**.

![[img/Pasted image 20251230121655.png]]

Al recibir un **paquete IP**, se consulta la **FIB** para verificar si existe una **entrada válida**. Si falta una entrada, se trata de una **adyacencia “glean”** en CEF, lo que significa que el paquete debe enviarse a la **CPU**, ya que CEF no puede manejarlo directamente.

Las entradas válidas de la FIB continúan el procesamiento buscando la **entrada de adyacencia apropiada** basada en el registro de la FIB. Las **adyacencias faltantes** activan el **proceso ARP**. Una vez que ARP se resuelve, se puede crear la **entrada CEF completa**.

Como parte del **proceso de reenvío de paquetes**, los **encabezados del paquete se reescriben**. El router **sobrescribe la dirección MAC de destino** con la **dirección MAC del router de siguiente salto** obtenida de la **tabla de adyacencias**, **sobrescribe la dirección MAC de origen** con la **dirección MAC de la interfaz de salida**, **decrementa el campo Time To Live (TTL)** del encabezado IP, **recalcula la suma de verificación (checksum)** del encabezado IP y, finalmente, **entrega el paquete al router de siguiente salto**.

> **Nota:** Los paquetes procesados por la **CPU** suelen estar sujetos a un **limitador de velocidad (rate limiter)** cuando existe una adyacencia inválida o incompleta, con el fin de evitar que se consuman ciclos de CPU necesarios para otros procesos esenciales.

> **Nota:** El **TTL** es un mecanismo de **prevención de bucles en Capa 3** que reduce el valor del TTL del paquete en **1 por cada salto de Capa 3**. Si un router recibe un paquete con un **TTL de 0**, el paquete se **descarta**.
### CEF por hardware

Los **ASICs** en routers basados en hardware son **costosos** de diseñar, producir y depurar. Los ASICs permiten **tasas de paquetes muy altas**, pero el compromiso es su **limitada flexibilidad**, ya que están cableados para realizar tareas específicas. Los routers están equipados con **NPUs** diseñadas para superar la inflexibilidad de los ASICs. A diferencia de los ASICs, las **NPUs son programables**, y su firmware puede modificarse con relativa facilidad.

La **principal ventaja** de las arquitecturas de **reenvío distribuido** es el **rendimiento de procesamiento de paquetes**, al **delegar** las responsabilidades de conmutación a los **motores de reenvío**. La conmutación de paquetes en plataformas de arquitectura distribuida se realiza mediante **CEF distribuido (dCEF)**, que permite que las **tarjetas de línea** descarguen información de reenvío hacia **ASICs y CPUs locales**. Esto posibilita que la conmutación se realice a **nivel distribuido**, incrementando así el **throughput** del router.

> **Nota:** El **CEF por software** en plataformas basadas en hardware **no se utiliza** para conmutar paquetes como en plataformas basadas en software; en su lugar, se usa para **programar el CEF por hardware**.
### Plantillas SDM

La **capacidad de direcciones MAC** que un switch puede manejar, en comparación con la **cantidad de rutas** que mantiene, depende de **dónde esté desplegado** en la red. La memoria utilizada para las **tablas TCAM** es **limitada** y se asigna de forma **estática durante el arranque** del switch. Cuando una sección de un recurso de hardware se llena, todo el procesamiento excedente se envía a la **CPU**, lo que **impacta seriamente el rendimiento** del switch.

Las **proporciones de asignación** entre las distintas tablas TCAM se almacenan y pueden modificarse mediante las **plantillas SDM (Switching Database Management)**. Existen **múltiples plantillas SDM** por modelo de switch. En los switches **Catalyst 9300**, las plantillas SDM pueden configurarse con el comando de configuración global  
**`sdm prefer {vlan | advanced}`**.  
Posteriormente, el switch debe **reiniciarse** con el comando **`reload`** para aplicar los cambios.

> **Nota:** Cada switch dentro de un **stack de switches** debe configurarse con la **misma plantilla SDM**.

La **Tabla 1-2** muestra el **número aproximado de recursos** disponibles por plantilla. Este número puede variar según la **plataforma del switch** o la **versión de software** utilizada. Estos valores suelen corresponder a funciones de **Capa 2 e IPv4**. Algunas funciones, como **IPv6**, utilizan el **doble de tamaño por entrada**, lo que significa que solo puede crearse **la mitad de las entradas**.
### Tabla 1-2: Número aproximado de recursos permitidos por plantilla

|Recurso|Advanced|VLAN|
|---|---|---|
|Número de VLANs|4094|4094|
|Direcciones MAC unicast|32,768|32,768|
|Direcciones MAC unicast en overflow|512|512|
|Grupos IGMP y rutas multicast|4096|4096|
|Grupos IGMP y rutas multicast en overflow|512|512|
|Rutas directamente conectadas|16,384|16,384|
|Rutas indirectas|7168|7168|
|Entradas de control de acceso basadas en políticas (ACEs)|1024|0|
|ACEs de clasificación QoS|3000|3000|
|ACEs de seguridad|3000|3000|
|ACEs de NetFlow|768|768|
|ACEs de policía de microflujos de entrada|256,000|0|
|ACEs de policía de microflujos de salida|256,000|0|
|ACEs de Flow SPAN (FSPAN)|256|256|
|Entradas del plano de control|512|512|

---

La **plantilla SDM actual** puede visualizarse con el comando **`show sdm prefer`**, como se demuestra en el **Ejemplo 1-17**.

**Ejemplo 1-17:** Visualización de la plantilla SDM actual
```
SW1# show sdm prefer
Showing SDM Template Info

This is the Advanced (high scale) template.
Number of VLANs:                          4094
Unicast MAC addresses:                    32768
Overflow Unicast MAC addresses:           512
IGMP and Multicast groups:                4096
Overflow IGMP and Multicast groups:       512
Directly connected routes:                16384
Indirect routes:                          7168
Security Access Control Entries:          3072
QoS Access Control Entries:               2560
Policy Based Routing ACEs:                1024
Netflow ACEs:                             768
Wireless Input Microflow policer ACEs:    256
Wireless Output Microflow policer ACEs:   256
Flow SPAN ACEs:                           256
Tunnels:                                  256
Control Plane Entries:                    512
Input Netflow flows:                      8192
Output Netflow flows:                     16384
SGT/DGT and MPLS VPN entries:             3840
SGT/DGT and MPLS VPN Overflow entries:    512

These numbers are typical for L2 and IPv4 features.
Some features such as IPv6, use up double the entry size;
so only half as many entries can be created.

```